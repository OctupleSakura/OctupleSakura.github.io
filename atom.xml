<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>QRC·Blog</title>
  
  <subtitle>好想一直窝着</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://octuplesakura.github.io/"/>
  <updated>2021-03-25T02:33:25.958Z</updated>
  <id>https://octuplesakura.github.io/</id>
  
  <author>
    <name>Octuple Sakura</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>拜拜，2020</title>
    <link href="https://octuplesakura.github.io/2021/03/09/%E6%8B%9C%E6%8B%9C%EF%BC%8C2020/"/>
    <id>https://octuplesakura.github.io/2021/03/09/拜拜，2020/</id>
    <published>2021-03-08T17:28:31.000Z</published>
    <updated>2021-03-25T02:33:25.958Z</updated>
    
    <content type="html"><![CDATA[<p>挥挥手，向着平平淡淡的2020告别</p><a id="more"></a><h3 id="flag">flag</h3><p>去年立下了一些flag，参考<a href="https://blog.octuplesakura.cn/2020/01/21/%E6%8B%9C%E6%8B%9C%EF%BC%8C2019/" target="_blank" rel="noopener">这一篇</a><br>2020的全球总决赛由于疫情的原因，改成了抽签制没能去成现场<br>去年从头开始的英语到现在也只能称作“半吊子”<br>去年说要做到的事情似乎都没能好好完成呢…</p><h3 id="疫情">疫情</h3><p>去年过年期间便开始，国内的疫情就开始爆发，到处都弥漫着不安的气息。而受到疫情的影响，不少公司也开始了远程办公，至此我便开始了很长一段的在家办公(摸鱼)生活</p><p>疫情影响的不仅仅是工作，甚至连基本的生活都会受到影响，那段最危险的时间连出门都小心翼翼，惴惴不安，连防毒面具都安排上了(笑)</p><p>那时候和阿宇在疫情刚开始的时候还一起帮硕照看了毛毛，才知道猫屎是有多臭…而且毛毛皮得很，仅是带去宠物医院剪个指甲都能跟杀猪一样，太草了hhh<br><img src="https://i.loli.net/2021/03/25/hYTWDlskuo52RZe.jpg" style="width: 500px; margin: 0 auto; margin-top: 20px;"></p><p>所幸在这场疫情当中，勇敢的人们前扑后继，将疫情控制了下来，至少到现在在国内是十分安心的，不过之后口罩是要常伴了…</p><h3 id="留学">留学</h3><p>留学的决定在工作之前便下定决心了，想来已经三年，在那之前，出国对于我而言是想都不敢想的事情。在那段小事故之后静养的时光中不由得让我开始深思，我是否该做点什么去改变现状，从而想去哪里看看的想法不禁出现在脑海里</p><p>这个选择意味着一切几乎是从头再来，甚至家庭也没办法给予太多经济上的支持，这样的决定是否有些不值呢？即便现在，我也没有得到答案，但这个想法成为了我在后面的这段工作时光中<strong>重要的动力</strong></p><p>20年的九月份便开始筹备留学材料了，大抵如下</p><ul><li>亲属关系公证</li><li>经费支付人资产证明</li><li>其余身份证，户口本等复印件</li><li>一寸照片</li></ul><p>当中也有个小插曲，由于很久以前出生的时候<strong>没有出生证明</strong>，导致后来的亲属公证变得异常的麻烦，为此老爸也不得不回了一趟老家专门处理，可能父母在之前也没有想到出生证的伏笔会埋到现在吧(哭)</p><p>十分感谢基友们的各种各样的帮助，也很感谢家里人的支持。不管怎样，材料总算是备齐并在10月份的时候提交了，目前在留刚拿到，受到日本疫情的影响估计还得3月下旬才能办理签证，希望疫情快点过去。至于这个决定值得与否，就留给<strong>几年后</strong>的我再来回答吧</p><h3 id="英语">英语</h3><p>19年的总结中提到了英语的事情，这也是为托福所做的一些铺垫吧，其中包括:</p><ul><li>✅  新概念2</li><li>✅  百词斩 - 托福单词(约4200词)</li><li>✅  扇贝 - 四级单词(约2000词)</li><li>✅  考满分tpo - 综合5套真题</li></ul><p>今年的成绩并没有很好…仅有58分，成绩出来时有被打击到，大抵还是学习的方向和方法不对，21年一定要跟托福分手!</p><p><img src="https://i.loli.net/2021/03/17/ItsU4NDTRSuleH8.png" style="width: 300px;margin: 0;border: 1px solid #eeeeee;"></p><h3 id="番剧">番剧</h3><p>推荐下 <strong>《恋如雨止》</strong>，今年最喜欢的番剧之一</p><p>霸权社少见的恋爱番，最开始设定让我有点接受不能，但没过多久我就真香了，个人觉得男女主的关系更像是引子，当然这可能需要自己去细细品味完之后才能感受到了</p><p><img src="https://i.loli.net/2021/03/17/mMSzgj7i6RhFcQp.png" alt=""></p><h3 id="生活">生活</h3><p>今年去的唯一一个能算旅行的地方，大概就是<strong>鼓浪屿</strong>了吧</p><p>说实话，我很少有觉得哪里哪里风景很好的时候，何况还是托福考的不好的情况下，更是没有太多的心情去欣赏景色。虽然如此，我依然想称赞一下鼓浪屿的景</p><ul><li>日光岩上</li></ul><p><img src="https://i.loli.net/2021/03/25/TrQo9XYZCiKkNSB.jpg" alt=""><br><img src="https://i.loli.net/2021/03/25/cOCvIdZx1fPWURG.jpg" alt=""></p><ul><li>菽庄花园</li></ul><p><img src="https://i.loli.net/2021/03/25/Fh9XMcHoLOb76eR.jpg" alt=""><br><img src="https://i.loli.net/2021/03/25/uhJ3oLgfHAsim5R.jpg" alt=""></p><ul><li>街头</li></ul><p><img src="https://i.loli.net/2021/03/25/BNF6rMOsjHtAec7.jpg" alt=""><br><img src="https://i.loli.net/2021/03/25/YxdNlL6XSoGpFTc.jpg" alt=""></p><p>希望大家有机会都能去看看呢，当然，趁着<strong>淡季</strong></p><h3 id="尾声">尾声</h3><p>这篇总结鸽了还蛮久，并且下一年也不一定再有时间抽出来更新blog了，下次更新也许就是一年之后了吧，目前的阶段我也没有太多精力写blog了</p><p>说实话，2020如果不是因为疫情，对我而言一定是太过平淡了。今年几乎在前端这一块没有再去研究新的东西了，工作之余的时间都专心在留学相关的事情了。组里的人几乎也都知道这事情，无论是欧文哥也好，丹姐也好，很早之前就开始沟通我的事情，对我几乎放水放了个太平洋一般，也没有需求，让我在工作上的压力骤降，几乎是白嫖了最后几个月的工资，真的不知道怎么去回报你们呢…</p><p>尬桑在今年也下定决心去追求自己想要的东西了，我们在处境上还蛮相似的，时不时也会吐槽一下现状，抱怨一下以前的事情。真心觉得他是个比我要聪明许多的人，至少在技术上的热情就比我要好的多的多，加油呀～不论结果至少未来要开开心心</p><p>F群的基友们陆陆续续开始工作/实习，我很明白实际上他们都是<strong>内心善良</strong>的人啊，不知不觉也相处了好多年，或许这就是物以类聚吧hhh，真心希望未来的他们能工作顺利。与他们不同的是我又回到了原点，说实话还蛮孤独的，一是因为身边几乎没有情况相似的例子可以参考，各种各样的事情几乎都得自己绞尽脑汁去想办法。二是心理上的压力，或者是说<strong>焦虑</strong>吧，本身我个人也不是容易向其他人倾诉些什么。想到未来的事情时不时也会有些害怕，或者说，心里没底，不过学会如何调节好这份情绪想必也是我要克服的困难之一了</p><p>2020就到此为止啦，希望2021能够顺顺利利，开开心心，这样就够了～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;挥挥手，向着平平淡淡的2020告别&lt;/p&gt;
    
    </summary>
    
      <category term="生活" scheme="https://octuplesakura.github.io/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="生活" scheme="https://octuplesakura.github.io/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>基于rollup的组件库-按需加载开发</title>
    <link href="https://octuplesakura.github.io/2020/06/28/%E5%9F%BA%E4%BA%8Erollup%E7%9A%84%E7%BB%84%E4%BB%B6%E5%BA%93%E6%8C%89%E9%9C%80%E5%8A%A0%E8%BD%BD%E5%BC%80%E5%8F%91/"/>
    <id>https://octuplesakura.github.io/2020/06/28/基于rollup的组件库按需加载开发/</id>
    <published>2020-06-28T02:34:23.000Z</published>
    <updated>2021-03-10T04:43:11.589Z</updated>
    
    <content type="html"><![CDATA[<p>由于项目开发是自己在公司内部整的，无法开源<br>另外本篇文章仅代表个人的一些思路，有更好的做法欢迎指正，谢谢</p><a id="more"></a><h3 id="选用rollup的理由">选用rollup的理由</h3><ol><li>tree-shaking(副作用相关)</li><li>多种格式输出(es, cjs)</li><li>配置简单，编译可读性好(webpack会带有runtime代码，__webpack_require__之类的)</li></ol><h3 id="按需加载">按需加载</h3><blockquote><p>简单来说就是摒弃不需要的组件代码，跟路由切分的作用稍微有些不同</p></blockquote><p>在组件库开发中，针对<strong>引用了该库的项目</strong>而言，在打包的时候就需要想办法去摒弃掉无用的代码，从而减小项目体积，那我们如何实现呢？有两种方案：</p><ul><li>tree-shaking<br>想办法让项目在打包的时候自己抖掉无用的组件代码，从而实现体积的优化</li><li>使用具体路径<br>引用时写上具体的组件目录，没有引用到的组件自然不会被打包进来</li></ul><p>当然，这两种方式都基于我们能够给组件库做<strong>code-splitting</strong>, 此类特性我们也可以在<a href="http://element-cn.eleme.io/#/zh-CN" target="_blank" rel="noopener">element-ui</a>和<a href="https://ant.design/" target="_blank" rel="noopener">antd</a>中看到相关提示</p><h4 id="antd">antd</h4><img src="/2020/06/28/基于rollup的组件库按需加载开发/antd-split.jpg"><h4 id="element-ui">element-ui</h4><img src="/2020/06/28/基于rollup的组件库按需加载开发/element-split.jpg"><h3 id="code-splitting">code-splitting</h3><blockquote><p>我们也可以叫他代码切割，通过某种手段将不同的代码块区分，并打包成单独的文件</p></blockquote><p>在rollup中有两种实现方式</p><ol><li>使用在配置文件中或者npm script中使用属性<strong>experimentalCodeSplitting</strong>来打包(验证可行，但打包出来的文件带hash值，暂时无法使用)，并且这个属性可能是早期rollup的产物，在后面的文档中并没有找到该属性</li><li>通过解析目录，用多配置文件的方式来打包(已验证可行)，具体写法可以参考官方文档中的<a href="https://rollupjs.org/guide/en/#configuration-files" target="_blank" rel="noopener">Configuration Files</a>这一节，指明了配置文件可为一个数组</li></ol>  <img src="/2020/06/28/基于rollup的组件库按需加载开发/rollup-array-output.jpg"><p>数组配置还可以使用<a href="https://github.com/rollup/rollup-plugin-multi-entry" target="_blank" rel="noopener">rollup-plugin-multi-entry</a>插件来完成</p><h4 id="入口文件处理">入口文件处理</h4><p>最后就是入口文件的处理，在编译后的组件库的入口文件处需要将所有的文件导出，效果类似下面这样</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> &#123; ComponentA &#125; <span class="keyword">from</span> <span class="string">'./A'</span></span><br><span class="line"><span class="keyword">export</span> &#123; ComponentB &#125; <span class="keyword">from</span> <span class="string">'./B'</span></span><br></pre></td></tr></table></figure><p>不过在自己实现的时候，rollup会根据打包时的入口文件静态依赖关系，将引用到的组件都打包到一个组件中<br>如果是这样的话，入口文件就不能够达到我们想要的<strong>tree-shaking</strong>的效果</p>  <img src="/2020/06/28/基于rollup的组件库按需加载开发/images.jpg"> <p>那就另辟蹊径一下吧，这个入口文件我们能不能自己生成呢？<br>我们需要知道所要导出的所有组件，在文件结构规范的情况下，需要导出的目录可以通过扫描 <strong>src</strong>目录实现<br>我们要做的只是如下一样将他写入到build目录就可以了</p>  <img src="/2020/06/28/基于rollup的组件库按需加载开发/code-example.jpg"><p>然后我就顺手写了个<a href="https://github.com/OctupleSakura/rollup-generate-entry" target="_blank" rel="noopener">小插件</a>，尽管我不并不知道这思路合不合理hhh<br>不过至少，它已经勉强能用了😆</p><h3 id="参考资料">参考资料</h3><ol><li><a href="https://rollupjs.org/guide/en/" target="_blank" rel="noopener">rollup</a></li><li><a href="https://ant.design/docs/react/introduce-cn" target="_blank" rel="noopener">antd</a></li><li><a href="https://github.com/ant-design/babel-plugin-import" target="_blank" rel="noopener">babel-plugin-import</a></li><li><a href="https://github.com/ElementUI/babel-plugin-component" target="_blank" rel="noopener">babel-plugin-component</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;由于项目开发是自己在公司内部整的，无法开源&lt;br&gt;
另外本篇文章仅代表个人的一些思路，有更好的做法欢迎指正，谢谢&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="https://octuplesakura.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="https://octuplesakura.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="rollup" scheme="https://octuplesakura.github.io/tags/rollup/"/>
    
  </entry>
  
  <entry>
    <title>拜拜，2019</title>
    <link href="https://octuplesakura.github.io/2020/01/21/%E6%8B%9C%E6%8B%9C%EF%BC%8C2019/"/>
    <id>https://octuplesakura.github.io/2020/01/21/拜拜，2019/</id>
    <published>2020-01-21T06:03:35.000Z</published>
    <updated>2021-03-17T11:10:06.166Z</updated>
    
    <content type="html"><![CDATA[<p>2019年真的感觉十分漫长，想来也算过得十分充实<br>神经大条的性格依旧还是没变，今年似乎也没有改过来呢</p><a id="more"></a><h3 id="开心的事情">开心的事情</h3><p>若说最开心的事情，当然是今年低分飘过了n2，具体可以看<a href="http://blog.octuplesakura.cn/2019/08/27/%E4%B8%83%E6%9C%88-%E5%8E%A6%E9%97%A8%E4%B9%8B%E8%A1%8C/" target="_blank" rel="noopener">这篇</a><br>看着大佬们的分数实在有些惭愧…<br>不得不说我的语言天赋实在太弱，但也算是完成了这段时间来的执念吧~<br><img src="https://github.com/OctupleSakura/show-img/raw/master/blog/2019-end/9b731e39cdb214596c6d0f0324c550f5.jpg" style="width: 300px;margin: 0;"><br>另外就是年末终于开始捡起英语了<br>这对于一个英语渣渣来说真的是可喜可贺<br>利用碎片时间背背单词，晚上回家看看书，真的感觉生活充实了不少<br>相对的，娱乐的时间少了很多，有舍才会有得吧</p><hr><h3 id="真香游戏">真香游戏</h3><p><strong>1. 巫师3</strong><br>今年唯一一款通关的游戏就只有《巫师3》了<br>巫师3的世界真的很吸引人，风景很美<br>再配合巫师3的bgm，感觉心情一下就平静下来了<br>另外出色的手感，精致的画面，各种剧情伏笔实在是妙哉<br>唯一值得吐槽的就是如果不小心从高一点的地方下来就会当场暴毙…<br><img src="https://github.com/OctupleSakura/show-img/raw/master/blog/2019-end/879967.png" style="width: 700px;margin: 0;"><br>和大多数人相同，也一样面临着到底选叶奈法还是特丽丝的难题…<br>特丽丝的红发实在太美，晚会上的特丽丝阿伟可以直接走一万遍流程<br>我个人也更加喜欢特丽丝的颜<br>但最后还是选择了叶奈法，毕竟叶奈法男主才是真爱<br>到最后也没有走一遍特丽丝线，以后有机会再回去吧~<br><img src="https://github.com/OctupleSakura/show-img/raw/master/blog/2019-end/899727.jpg" style="width: 700px;margin: 0;"></p><p><strong>2. 二之国2：亡灵之国</strong><br>画风实在是太！对！我！口！味！了！<br>尽管剧情上被人吐槽太幼稚，但瑕不掩瑜，出色的打击感和画风还是让我喜欢的不行<br>可惜在steam上不打折的价格实在太高，建议打折入手<br>还有一点需要吐槽的是，等级经常会比怪物差很多<br>至少我是天天被污染怪摁在地上摩擦…(逃<br><img src="https://github.com/OctupleSakura/show-img/raw/master/blog/2019-end/d9a834cec62f5960c869dd204d849787.jpg" style="width: 700px;margin: 0;"></p><p><strong>3. 崩坏3</strong><br>玩了近三年吧，因为各种各样的原因在今年还是退坑了…<br><img src="https://github.com/OctupleSakura/show-img/blob/master/blog/xiamen/sad.jpg?raw=true" style="width: 300px;margin: 0;"><br>虽然皮肤比起LOL的皮肤更加贵，但是更愿意买三蹦子的<br>零零碎碎的也买了不少的皮肤，火八的<strong>绮罗幻梦</strong>真的太好看了！！<br>到最后也只是一个苦痛红莲升降机，但养成游戏的成就感很让人满足，这就足够了吧<br><img src="https://github.com/OctupleSakura/show-img/raw/master/blog/2019-end/104839.jpg" style="width: 600px;margin: 0;"><br>也许有一天我会回来吧<br>我永远喜欢八重樱！！</p><hr><h3 id="特别喜欢的番剧">特别喜欢的番剧</h3><p>b站2019的年度报告出来之后让我自己也有点懵逼<br>补了<strong>114</strong>部番，今年补的番不少，有一部特别喜欢！<br>推荐下 <strong>《relife》</strong><br><img src="https://github.com/OctupleSakura/show-img/raw/master/blog/2019-end/716883.jpg" style="width: 700px;margin: 0;"><br>没有很精良的画面，甚至连完结篇都是粉丝众筹制作的，可谓用爱发电<br>尽管如此，丝毫不影响我对这部番剧的喜爱，至少男女主的狗粮我吃的很开心<br>番剧之后把顺便漫画补完了，真舍不得完结</p><hr><h3 id="一些经历">一些经历</h3><p><strong>生日</strong><br>老妹偷偷拉了朋友们给我惊喜(尽管最后暴露了hhh)，当时真的很开心<br>不知不觉已经在奔3的路上了，一点真实感都没有呢…</p><p><strong>技术栈</strong><br>今年开始，算是真正的入了react的坑了<br>踩了太多太多的坑，但对我真的帮助很大，感谢大佬们给我的帮助</p><p><strong>前端组重组</strong><br>10月份初，前端组的同事们纷纷离职了，包括一起相处一年的leader<br>当时心情特别低落，也一度想要跑路<br>最后还是留下来了，毕竟人各有志<br>祝愿他们前程似锦</p><p><strong>前端生涯倒计时</strong><br>没有意外的话，2020年也许是作为前端的最后一年了吧<br>入坑前端也有不少日子了，这份职业给我带来了不少东西<br>不过相比于此，能够去追寻自己喜欢的东西，更值得开心吧<br>希望明年也能够顺利呢</p><hr><h3 id="明年的目标">明年的目标</h3><ol><li>好好攒钱</li><li>学好英语</li><li>现场看一次LOL全球总决赛</li></ol><p>flag先提前立着吧，希望明年能够完成<br>给大家拜个早年，各位新年顺顺利利，心想事成鸭~<br>拜拜，2019<br><img src="https://github.com/OctupleSakura/show-img/raw/master/blog/2019-end/2020122001.jpg"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2019年真的感觉十分漫长，想来也算过得十分充实&lt;br&gt;
神经大条的性格依旧还是没变，今年似乎也没有改过来呢&lt;/p&gt;
    
    </summary>
    
      <category term="生活" scheme="https://octuplesakura.github.io/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="生活" scheme="https://octuplesakura.github.io/tags/%E7%94%9F%E6%B4%BB/"/>
    
      <category term="杂谈" scheme="https://octuplesakura.github.io/tags/%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>为什么我们要用typescript</title>
    <link href="https://octuplesakura.github.io/2019/10/09/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E4%BB%AC%E8%A6%81%E7%94%A8typescript/"/>
    <id>https://octuplesakura.github.io/2019/10/09/为什么我们要用typescript/</id>
    <published>2019-10-09T03:58:59.000Z</published>
    <updated>2021-03-10T11:12:37.932Z</updated>
    
    <content type="html"><![CDATA[<p>如果让我选一个用了就离不开的东西，那么选项当中一定会有一个东西<br>那就是<strong>typescript</strong></p><a id="more"></a><h3 id="前言">前言</h3><p>ts对于前端开发来说是个门槛。为什么呢？它的学习成本并不低，并且现状是，大部分人一开始都会对着满屏幕的红色波浪线一脸懵逼，不知所措，然后放弃</p><p>实际上，半年前的我也是抱着这样的心态，因此，总得有足够充分的理由来让我们在学习成本比较高的情况下仍然去学习它，毕竟js确实已经够用了<br><img src="https://github.com/OctupleSakura/show-img/raw/master/blog/ts/faker-ll.jpg" style="width:300px;margin: 0;"></p><p>超级感谢leader在这方面给我的帮助(已经是前leader了T_T)，真的学习到了很多。在这里，我强烈安利这个东西，它确确实实的能够提升你的开发体验，且听我慢慢道来</p><h3 id="ts好玩在哪里">ts好玩在哪里</h3><p>先根据自己的经验来扯一下ts到底有什么吸引了我</p><h4 id="规避类型引起的报错">规避类型引起的报错</h4><p>没有对比就没有伤害，诚然，js较为宽泛的语法降低了入门的门槛，但同时也有一定的弊端，相信用js的老哥们偶尔会遇到类型问题，引发报错，不胜其烦</p><p>ts在这方面做了很好的补足，通过给变量规定类型，规避了很多许多类型相关的低级错误<br><img src="https://github.com/OctupleSakura/show-img/raw/master/blog/ts/var-type.jpg" style="width:400px;margin: 0;margin-top: 10px;"></p><p>另外一些静态类型该有的，ts也能给你提供，比如常见的interface，enum，泛型，装饰器等等，在此之上，还包含很多通过ts基础语法实现的一套api，例如Pick，Extract，Extract巴拉巴拉。因此在组件传值，接口数据方面很多都可以应用到，十分便利</p><h4 id="代码即文档">代码即文档</h4><p>ts有一部分的好处还体现在<strong>接口数据</strong>上，在写接口的过程中，如果没有文档或者注释的话，很难知道一个接口到底会有什么数据。如果通过ts来给接口返回数据编写类型，只需要看编辑器的提示就能知道一个接口到底需要什么参数，会返回什么数据</p><p>不仅如此，在遇到一些复杂接口的时候，往往需要一定的<strong>理解成本</strong>，通过ts对接口做一些简单的设计，能够使理解成本降低，对我们开发体验也有着很大的帮助</p><blockquote><p>推荐一个<a href="http://www.json2ts.com/" target="_blank" rel="noopener">小工具</a>，可以把json转换成ts的类型。</p></blockquote><p>举个简单的栗子0.0<br>如果我们在做一个发送消息的接口，这个消息有不同的类型，例如文字消息、音频消息、视频消息等等，我们要去怎么设计它？<br><img src="https://github.com/OctupleSakura/show-img/raw/master/blog/ts/jojo.jpg" style="width:200px;margin: 0;margin-top: 10px;"><br>相信你肯定就一下想到了做一个message的base interface，然后通过extends来实现各种不同类型的消息</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  ** 类型文件</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过keyof关键字来拿到form类型的key值</span></span><br><span class="line"><span class="keyword">export</span> type TMessageKey = keyof IMessageType</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将可能用到的类型放到一个interface里面</span></span><br><span class="line"><span class="keyword">export</span> interface IMessageType &#123;</span><br><span class="line">  voice: IAudioSendMessage</span><br><span class="line">  text: ITextSendMessage</span><br><span class="line">  image: IImageMessage</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  ** 接口层</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过泛型限定在key当中，然后同时可以根据泛型来拿到对应的interface</span></span><br><span class="line">public <span class="keyword">static</span> MessageSend&lt;T extends TMessageKey&gt;( </span><br><span class="line">  form: IMessageType[T]</span><br><span class="line">) &#123;</span><br><span class="line">  <span class="comment">//...发送消息</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  ** 逻辑层</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过手动的传入一个类型，明确的声明所需要传的值</span></span><br><span class="line">MessageSend&lt;<span class="string">'image'</span>&gt;(&#123;</span><br><span class="line">  <span class="comment">// image form data</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>通过类型的推演，使得我们在使用<strong>MessageSend</strong>接口时，只需要修改传递的消息类型，就可以得到不一样的参数类型</p><h4 id="合理的设计">合理的设计</h4><p>在工作当中曾经遇到这样一个问题，我想设计一个<strong>单选框组件</strong>。对应的，我需要一个<strong>default</strong>值(默认选中)，以及<strong>item</strong>(每个选项包含的一些参数)，那么问题来了，如何通过ts去限制default值在item的范围内呢？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">interface option&lt;S&gt; &#123;</span><br><span class="line">  value: S</span><br><span class="line">  label: string</span><br><span class="line">  key: string | number</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface IRadioProps&lt;V, T&gt; &#123;</span><br><span class="line">  item: V[]</span><br><span class="line">  defaultValue?: T</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">Radio</span>&lt;</span></span><br><span class="line">  T extends V['value'],</span><br><span class="line">  V extends item&lt;S&gt;,</span><br><span class="line">  S extends string</span><br><span class="line">&gt;(props: IRadioProps&lt;V, T&gt;) &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>感谢学长，这个问题之前咨询过他，还特意帮我到stackoverflow提问了，具体的回答可以看<a href="https://stackoverflow.com/questions/56651130/is-there-possible-to-determine-parameter-is-one-of-the-given-collection-types" target="_blank" rel="noopener">这里</a></p></blockquote><p>答案也很简单，通过<strong>泛型</strong>，泛型是什么就不赘述了，直接去看ts的文档便能了解。通过将泛型限制在item的value中来使得defaultValue一定为item中的某个value，并给出对应的提示，让组件限制更加合理</p><h3 id="结尾">结尾</h3><p>放下typescript的<a href="https://www.typescriptlang.org/docs/home.html" target="_blank" rel="noopener">官网</a>。</p><p>总之，ts是一个非常值得学习的东西，不仅能提升开发体验，同时能够让前端入门的小伙伴了解到类型系统，一举两得</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如果让我选一个用了就离不开的东西，那么选项当中一定会有一个东西&lt;br&gt;
那就是&lt;strong&gt;typescript&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="https://octuplesakura.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="https://octuplesakura.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="typescript" scheme="https://octuplesakura.github.io/tags/typescript/"/>
    
  </entry>
  
  <entry>
    <title>厦门之行</title>
    <link href="https://octuplesakura.github.io/2019/08/27/%E5%8E%A6%E9%97%A8%E4%B9%8B%E8%A1%8C/"/>
    <id>https://octuplesakura.github.io/2019/08/27/厦门之行/</id>
    <published>2019-08-27T01:53:00.000Z</published>
    <updated>2021-03-10T11:00:18.162Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>啊哈，说起来这是我第一次一个人出远门呢</p></blockquote><p>要说为什么要去厦门，还跟我粗心大意有关系。在今年的12月份日语n2考试上，最终以5分之差落败，详情可以看<a href="http://blog.octuplesakura.cn/2019/01/30/%E5%86%8D%E4%B8%80%E6%AC%A1%EF%BC%8C%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B/" target="_blank" rel="noopener">这篇</a></p><a id="more"></a><p>为了<strong>再一次</strong>挑战n2，并且成功的拔掉我的flag，于是又一次头铁报名。不幸的是，错过了报名的第一天，并且省内的位置也全部满员。想了想，那就报一个离省内近一些的地方吧，权当是旅游了</p><p>正好考试也是在周末，也不用上班。周五晚上睡觉前定了定神，心里一直默念没有bug没有bug…<br><img src="https://github.com/OctupleSakura/show-img/blob/master/blog/xiamen/dog.jpg?raw=true" style="width:300px;"></p><p>由于是早上10点钟的高铁，也不用刻意起的太早，吃完早饭大概8:30就出门赶高铁了，高铁站的人很多，不过沿途上的风景很漂亮，心情也好起来了<br><img src="https://github.com/OctupleSakura/show-img/blob/master/blog/xiamen/xmh.jpg?raw=true" style="width: 100%;"><br>到厦门时已经是下午两点，到民宿的时候有种筋疲力尽的感觉<br><img src="https://github.com/OctupleSakura/show-img/blob/master/blog/xiamen/xmj.jpg?raw=true" style="width: 100%;"><br>虽然是考试，但是既然来了厦门总得去逛一逛，不然总感觉有些可惜</p><hr><h3 id="曾厝垵">曾厝垵</h3><p>由于报名了厦门大学的考点，附近可以去看的地方还蛮多的，附近比较出名的应该就是<strong>曾厝垵</strong>了，并且我也不想在民宿从下午一直复习到晚上，正好它离住宿的地方还算近。更重要的是，我的晚饭还没有着落，想到这里，直接背上书包找摩拜前往目的地</p><p>实际上还蛮好找的，从民宿门口出来拐个弯，沿着大路径直往前骑就可以看到曾厝垵的牌子了(实际上这是后门)<br><img src="https://github.com/OctupleSakura/show-img/blob/master/blog/xiamen/zcahm.jpg?raw=true" style="width: 100%;"><br>大众点评找到评分高的网红小吃，直接开启吃吃逛逛模式！<br><img src="https://github.com/OctupleSakura/show-img/blob/master/blog/xiamen/zcajd.jpg?raw=true" style="width: 100%;"><br><img src="https://github.com/OctupleSakura/show-img/blob/master/blog/xiamen/xmg.jpg?raw=true" style="width: 100%;"><br>炸土豆，超好吃的这个(幼儿园级词汇量), 炸蘑菇，有很多口味，好次！</p><div style="width: 625px;margin:0 auto;"><img src="https://github.com/OctupleSakura/show-img/blob/master/blog/xiamen/zcatd.jpg?raw=true" style="width: 300px;display:inline-block;"><img src="https://github.com/OctupleSakura/show-img/blob/master/blog/xiamen/zcamg.jpg?raw=true" style="width: 300px;display:inline-block;">  </div>曾厝垵里面不止一家，而且小哥也很热♂情<img src="https://github.com/OctupleSakura/show-img/blob/master/blog/xiamen/mgcq.jpg?raw=true" style="width:100%;">  <p>这是一个据说敲了三下能发财的锣鼓，啥也不说了，上去咣咣咣就是三下，敲完就跑（无视路人的看沙雕一般的眼神）<br><img src="https://github.com/OctupleSakura/show-img/blob/master/blog/xiamen/zcalg.jpg?raw=true" style="width: 300px;margin-bottom: 20px;"><br>正门，逆向通关，实际上逛了还蛮久的，光顾着溜达也没有拍很多照片，毕竟明天还有考试要完成<br><img src="https://github.com/OctupleSakura/show-img/blob/master/blog/xiamen/zcazm.jpg?raw=true" style="width: 100%;"></p><p>回民宿的路上看到有人在拍婚纱照，xmsl，我会不会也有这样的一天呢…<br><img src="https://github.com/OctupleSakura/show-img/blob/master/blog/xiamen/xmjd.jpg?raw=true" style="width: 100%;"></p><hr><h3 id="n2考试">n2考试</h3><p>第二天，睡到9点起床，刷牙，吃早餐，复习，中午直奔厦门大学考点准备考试，提早到了考点，就先进楼里面看了看教室<br><img src="https://github.com/OctupleSakura/show-img/blob/master/blog/xiamen/xmjs.jpg?raw=true" style="width: 100%;"><br>等待考试中…小姐姐好多，因为很久没有考试的关系心里也很紧张<br><img src="https://github.com/OctupleSakura/show-img/blob/master/blog/xiamen/wait.jpg?raw=true" style="width: 100%;"></p><p><strong>考试ing…</strong></p><p>随着最后一道听力题的结束，考试也正式宣告结束了，此行的目的也正式达成了。长长的吁了一口气，压力随之消失，取而代之的是莫名的失落感<br><img src="https://github.com/OctupleSakura/show-img/blob/master/blog/xiamen/xmln.jpg?raw=true" style="width: 100%;"><br>收拾好东西后便缓缓的走下楼，大厅里面已经站满了很多人，挤入人群之中办理邮寄，虽然不知道能不能过_(:3 」∠ )_<br><img src="https://github.com/OctupleSakura/show-img/blob/master/blog/xiamen/xmry.jpg?raw=true" style="width: 300px;"><br>在离开之前还是先膜拜了一下厦门大学的软件学院，正好在考点附近。之后时间不太够了，只能先赶高铁了。在从厦大出来之后就猛地冲到高铁站附近的m记先买了份套餐，果然m记的味道无论在哪里都是一样的呢<br><img src="https://github.com/OctupleSakura/show-img/blob/master/blog/xiamen/sb.jpg?raw=true" style="width: 300px;"><br>在出来之前书包的拉链还坏了…只能一直保持着这个状态回去了<br><img src="https://github.com/OctupleSakura/show-img/blob/master/blog/xiamen/sad.jpg?raw=true" style="width: 300px;"><br>晚上大概10点左右回到了深圳，行程结束啦，希望之后能有机会好好的去玩一遍<br><img src="https://github.com/OctupleSakura/show-img/blob/master/blog/xiamen/szbz.jpg?raw=true" style="width: 100%;"><br>再见啦，厦门</p><hr><h3 id="后续">后续</h3><p><strong>2019.8.27</strong>，这天是n2公布考试结果的日子，距离考试结束已经一个半月，想起上一次考试的成绩，以及在那之后立下的flag，心情就非常的紧张<br><img src="https://github.com/OctupleSakura/show-img/blob/master/blog/xiamen/cj.png?raw=true" style="width: 300px;"><br>这一次终于过啦！虽然是个不太能说得出口的成绩，但总算是合格了。高兴到差点在公交车上蹦起来（无视路人的看沙雕一般的眼神*2）</p><p>希望大家都能逢考必过~<br><img src="https://github.com/OctupleSakura/show-img/blob/master/blog/xiamen/happy.jpg?raw=true" style="width: 300px;"></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;啊哈，说起来这是我第一次一个人出远门呢&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;要说为什么要去厦门，还跟我粗心大意有关系。在今年的12月份日语n2考试上，最终以5分之差落败，详情可以看&lt;a href=&quot;http://blog.octuplesakura.cn/2019/01/30/%E5%86%8D%E4%B8%80%E6%AC%A1%EF%BC%8C%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这篇&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="生活" scheme="https://octuplesakura.github.io/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="旅行" scheme="https://octuplesakura.github.io/tags/%E6%97%85%E8%A1%8C/"/>
    
      <category term="考试" scheme="https://octuplesakura.github.io/tags/%E8%80%83%E8%AF%95/"/>
    
      <category term="生活" scheme="https://octuplesakura.github.io/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>让我们用rollup来摸鱼吧</title>
    <link href="https://octuplesakura.github.io/2019/06/26/%E8%AE%A9%E6%88%91%E4%BB%AC%E7%94%A8rollup%E6%9D%A5%E6%91%B8%E9%B1%BC%E5%90%A7/"/>
    <id>https://octuplesakura.github.io/2019/06/26/让我们用rollup来摸鱼吧/</id>
    <published>2019-06-26T08:31:25.000Z</published>
    <updated>2021-03-08T17:34:46.158Z</updated>
    
    <content type="html"><![CDATA[<p><strong>rollup</strong>是个什么东东，和<strong>webpack</strong>一样,是我js模块打包器哒！但是更加的轻量级，并且上手十分简单</p><a id="more"></a><h2 id="和webpack的对比">和webpack的对比</h2><h3 id="1-tree-shaking">1. tree-shaking</h3><p>利用es模块的静态分析，以及作用域分析等等，找到无用的代码，在打包的时候删除，从而达到缩减代码体积的目的，这也是为什么如果采用了<strong>commonjs</strong>的模式便无法进行<strong>tree-shaking</strong>的原因<br>而这一方面rollup首先提出并实现，webpack从2开始支持，并且ugilfy也支持做这个工作，babel更新babel7，之后也优化了关于一些副作用上面的问题，同时rollup做了程序流分析的原因，这一方面做得比较好</p><p>实际上目前的打包工具的tree-shaking都会有些缺陷，原因基本都是因为函数的<strong>副作用</strong>导致，并且经过babel打包过后，如果你定义了类的话，为了符合es6的语义在编译之后会有一个 <strong>_createClass</strong>函数，函数里面采用<strong>Object.defineProperty</strong>来定义类里面的方法，从而产生了副作用，无法被<strong>tree-shaking</strong><br><img src="https://github.com/OctupleSakura/show-img/blob/master/blog/rollup/parse.png?raw=true" style="border: 1px solid #eeeeee;margin: 10px 0;"><br>而如果开启babel的<strong>loose模式</strong>的话，会直接通过在原型链上定义方法的形式来实现，因此loose模式下的类定义基本可以被正确的<strong>tree-shaking</strong><br><img src="https://github.com/OctupleSakura/show-img/blob/master/blog/rollup/loose.png?raw=true" style="border: 1px solid #eeeeee;margin: 10px 0;"><br>有兴趣的话可以用babel的线上编译来做尝试，大体就不深究了，可以展开很长，这篇文章目的也不是主要探讨这个</p><h4 id="2-配置">2. 配置</h4><p>从webpack和rollup的文档对比来看，显而易见，webpack要比rollup繁杂的多，同时rollup也没有loader的这样的说法,基本所有的编译工作都是依赖于plugin来完成，而webpack的编译工作则基本依赖于loader，plugins来做拓展和优化等loader无法做到的事情。<br><img src="https://github.com/OctupleSakura/show-img/blob/master/blog/rollup/plugins.png?raw=true" style="border: 1px solid #eeeeee;margin: 10px 0;"><br>并且webpack在一些功能的配置项上要比rollup要多一些，比如<strong>externals</strong>，rollup只能选择dep或者peer全部做externals，而webpack可以选择单独对某个模块执行</p><h2 id="rollup适合做什么">rollup适合做什么</h2><p>为什么要说rollup适合做类库，而webpack适合做应用呢，有不少的原因，rollup相对于webpack一些核心功能的缺失，比如<br><strong>代码切割</strong>和<strong>hmr</strong>，以及<strong>静态资源的处理</strong>，这些原因决定了rollup并不适合一个大型的应用。</p><blockquote><p>ps: 写博客的时候发现rollup已经有了针对es模块做代码切割的实验性语法，通过在npm script加上–experimentalCodeSplitting来实现，另外常规的代码切割需要通过import()来实现，给中文文档坑了…</p></blockquote><p>同时，rollup在模块的一些处理上还是有一些坑的，rollup默认支持es模块的处理，对于commonjs的模块需要额外的插件，另<br>外在代码压缩的时候，一般都会想到<strong>uglifyjs</strong>，实际上他也只支持<strong>es5</strong>，uglify-es虽然支持es6，但是也已经停止维护。<br><img src="https://github.com/OctupleSakura/show-img/blob/master/blog/rollup/uglify.png?raw=true" style="border: 1px solid #eeeeee;margin: 10px 0;"><br>所以使用rollup做压缩代码的时候，更好的选择是<strong>terser</strong>，他是<strong>uglify-es</strong>的一个分支，支持es6+，并且如今也还在继续更新。<br>另外如果要做一些ui库的话还是更推荐webpack，像按需加载这种功能基本上是不能在rollup上实现的，调用了其中的一个组<br>件，项目打包的时候会把所有的内容都给打包进去，这种场景还是webpack更适合一些。</p><h2 id="rollup的一些优化">rollup的一些优化</h2><p>在优化rollup的代码上我们需要做一些什么样的工作？</p><h3 id="1-external">1. external</h3><p>rollup的external需要通过插件来实现，公司项目写库的时候用的是<strong>rollup-plugin-peer-deps-external</strong>这个组件来<br>配置，基本上也很简单，最多只用配置下面两个选项</p><ul><li>includeDependencies(是否包含dep)</li><li>packageJsonPath(packjson路径)</li></ul><p>它主要针对的是<strong>peerDependencies</strong>这个东西，一般是写插件或者库才会用到的一个package的属性<br><img src="https://github.com/OctupleSakura/show-img/blob/master/blog/rollup/peer.png?raw=true" style="border: 1px solid #eeeeee;margin: 10px 0;"><br>值得一提的是这个属性在npm3中已经被取消了，但是yarn中还在继续使用，它的作用是为了让声明项目的核心依赖库，当有人在<br>调用你的项目时，如果你已经安装过peerDependencies所包  含的依赖库的话则忽略，如果没有则安装，并且可以避免用户多<br>次下载同一插件(这个地方好像npm已经做过优化了= =)<br>除了这个以外还有<strong>rollup-plugin-auto-external</strong>这个插件，但是我木有用过，看了配置项应该也差不多</p><h3 id="2-uglify和terser">2. uglify和terser</h3><p>上面已经大概说过uglify和terser的一些关系，就不再多赘述了，基本上插件里面添加一遍就完事了，具体的配置项就直接看源<br>项目的<a href="https://github.com/TrySound/rollup-plugin-terser#readme" target="_blank" rel="noopener">说明</a>吧</p><p>其余就是<strong>sourcemap</strong>之类的一些优化了，判断一下是否是生产环境就o啦~</p><h2 id="参考链接">参考链接</h2><p>关于<a href="https://juejin.im/post/5a5652d8f265da3e497ff3de" target="_blank" rel="noopener">tree-shaking</a><br>关于<a href="https://github.com/SamHwang1990/blog/issues/7" target="_blank" rel="noopener">peerDependencies</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;rollup&lt;/strong&gt;是个什么东东，和&lt;strong&gt;webpack&lt;/strong&gt;一样,是我js模块打包器哒！但是更加的轻量级，并且上手十分简单&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="https://octuplesakura.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="https://octuplesakura.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="rollup" scheme="https://octuplesakura.github.io/tags/rollup/"/>
    
  </entry>
  
  <entry>
    <title>日文系列 - 根据状态而变化的语法</title>
    <link href="https://octuplesakura.github.io/2019/05/20/%E6%97%A5%E6%96%87%E7%B3%BB%E5%88%97-%E6%A0%B9%E6%8D%AE%E7%8A%B6%E6%80%81%E5%8F%98%E5%8C%96%E7%9A%84%E8%AF%AD%E6%B3%95/"/>
    <id>https://octuplesakura.github.io/2019/05/20/日文系列-根据状态变化的语法/</id>
    <published>2019-05-20T01:51:30.000Z</published>
    <updated>2021-03-10T05:10:44.585Z</updated>
    
    <content type="html"><![CDATA[<p><strong>n5-n2</strong>的语法都有可能会涉及到，算是一个简单的总结，加上最近日语考试又要到了，为了让自己不要那么怠惰。一些稍微复杂的语法还是会加上自己的理解，一是新标日的说明本来有些就比较难懂，二是这样也方便自己记忆。</p><a id="more"></a><h3 id="1-次第で-は-次第だ">1. 次第で(は)/次第だ</h3><h5 id="接续方式">接续方式:</h5><p><strong>名词</strong> + 次第で(は)/次第だ</p><h5 id="意义">意义</h5><p>与各种状况相适应</p><h5 id="例句">例句</h5><p>先生次第で、生徒の学力は違ってくる<br>(不同的老师，学生的学习能力也会不同)</p><h5 id="补充">补充</h5><p>&quot;次第&quot;的用法比较多，其他的比如：<strong>动词(ます形去ます)</strong> + 次第<br>表示&quot;一但发生某事就…&quot;的意思，要注意不能弄混</p><h3 id="2-とともに">2. とともに</h3><h5 id="接续方式-v2">接续方式:</h5><ol><li><strong>动词辞书形(原型)/一类(い形)形容词/名词</strong> + とともに</li><li><strong>二类(な形)/名词 + である</strong> + とともに</li></ol><h5 id="意义-v2">意义</h5><p>随着…的变化而变化/与…的同时</p><h5 id="例句-v2">例句</h5><p>原因を調査するとともに、再発を防ぐための努力もしていかなければならない<br>(在调查原因的同时，也要防止再次发生)</p><h3 id="3-による-によって">3. による/によって</h3><h5 id="接续方式-v3">接续方式</h5><p><strong>名词/动词 + か + どうか</strong> + による/によって</p><h5 id="意义-v3">意义</h5><p>用于表示不同情况，后面一般多用&quot;違う&quot;或者&quot;変わる&quot;</p><h5 id="例句-v3">例句</h5><p>林さんが行くかどうかによって、わたしもどうするか決めます<br>(我会根据林先生是否要去来决定怎么做)</p><p>[はし]と言っても、そのかたちや材料は国や地域によって違う<br>(虽然都叫筷子，但他的形状和材料根据国家和地区也各不相同)</p><h5 id="补充-v2">补充</h5><p><strong>による/によって</strong>除了上文介绍的以外，还有以下两个意思<br><strong>1. 动作发出者</strong><br><strong>2. 信息来源</strong><br>注意要根据上下文来判断具体所代表的意义</p><h3 id="4-题外话-日语中的告白">4. 题外话 - 日语中的告白</h3><p>动漫中常常有不少的告白场景，<strong>“おまえのこと、好きだ”</strong> 等等<br><img src="https://github.com/OctupleSakura/show-img/blob/master/blog/japan/wy.jpg?raw=true" alt="表情包"><br>一般对一个人表示某种感情，用到了类似&quot;好き&quot;或者&quot;嫌い&quot;等词语。比方说讨厌的话，可能要这么说，<strong>“君のこと、大嫌い！”</strong> 会发现在表示人的单词后面会接上一个 <strong>“こと”</strong> 。如果不加 <strong>“こと”</strong> 的话可能会单纯表示你只是喜欢这个 <strong>“物体”</strong>，而非这个 <strong>“人”</strong> 之后用到的话可能要注意一下。</p><h4 id="月が綺麗ですね-月色真美">月が綺麗ですね(月色真美)</h4><p>&quot;月色真美&quot;是来自夏目漱石在学校当英文老师的时给学生出的一篇短文翻译的故事(自行google或者百度)。说法有很多，其中比较多的是&quot;好き(suki)&quot;和&quot;月(tsuki)&quot;的读音比较相近，个人还是非常喜欢这种亚洲文化中独有的<strong>含蓄</strong>的表达方式<br><img src="https://github.com/OctupleSakura/show-img/blob/master/blog/animate/p2435488420.webp?raw=true" style="width:400px"><br>有一部番剧也叫<strong>月色真美</strong>，有机会的话可以补一补鸭，毕竟平平淡淡才是真=͟͟͞͞( •̀д•́)</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;n5-n2&lt;/strong&gt;的语法都有可能会涉及到，算是一个简单的总结，加上最近日语考试又要到了，为了让自己不要那么怠惰。一些稍微复杂的语法还是会加上自己的理解，一是新标日的说明本来有些就比较难懂，二是这样也方便自己记忆。&lt;/p&gt;
    
    </summary>
    
      <category term="学习" scheme="https://octuplesakura.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="日语" scheme="https://octuplesakura.github.io/tags/%E6%97%A5%E8%AF%AD/"/>
    
  </entry>
  
  <entry>
    <title>snabbdom简单解读</title>
    <link href="https://octuplesakura.github.io/2019/04/01/snabbdom%E7%AE%80%E5%8D%95%E8%A7%A3%E8%AF%BB/"/>
    <id>https://octuplesakura.github.io/2019/04/01/snabbdom简单解读/</id>
    <published>2019-04-01T02:55:17.000Z</published>
    <updated>2021-03-09T04:52:57.624Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/snabbdom/snabbdom" target="_blank" rel="noopener">snabbdom</a>是非常经典的一个库了。<br>曾经在知乎上看到有这样一个<a href="https://www.zhihu.com/question/29380608" target="_blank" rel="noopener">问题</a>，发现<strong>virtual-dom</strong>也是不少人都造过的轮子。<br>snabbdom的牛逼之处更多在于思想，而不是在于代码有多么的精妙，这一点在react和vue都用virtual-dom的思想去做dom的处理而又对其做了优化这件事情中可见一斑。</p><a id="more"></a><h3 id="前言">前言</h3><ol><li>实际上在刚看到源码的时候也是有些一脸懵逼，所以就从<a href="https://github.com/snabbdom/snabbdom/commits/master?after=81da0c124257d393e29796a13e92f6f3016ac20d+447" target="_blank" rel="noopener">第一个commit</a>开始看了，确实不失为一个好方法，虽然可能花的时间会稍微长一点0.0，好处在于可以了解到作者最初的想法。</li><li><strong>diff</strong>的部分实际上已经有非常非常多讲的很通俗的文章，写的辣鸡的地方可以评论补(peng)充(wo)啦，感谢！</li></ol><h3 id="项目结构">项目结构</h3><p>先来看下项目结构<br><img src="https://github.com/OctupleSakura/show-img/raw/master/blog/snabbdom/snabbdom-tree.jpg" alt="项目结构"><br>modules文件夹里面都是拆分出来的简单替换和对比的一些函数，都比较简单可以自行查看。<br>hero文件里面放了snabbdom的钩子函数，也就是hook，会在snabbom的init函数调用的时候收集，在对应的时候执行，同时里面通过<strong>requestAnimationFrame</strong>做了一些动画上的优化。<br>其他比较核心的有</p><ul><li><p>h函数（传入对应参数生成vnode）</p></li><li><p>html（domapis一些dom-api封装）</p></li><li><p>snabbdoms.bundle（打包的一些处理）</p></li><li><p>snabbdom（主文件核心逻辑都在这里，主要分析这个里面的代码）</p></li><li><p>thunk（对patch的一些优化）</p></li><li><p>vnode（定义了virtual-dom的结构）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> interface VNodeData &#123;</span><br><span class="line">  props?: Props;</span><br><span class="line">  attrs?: Attrs;</span><br><span class="line">  class?: Classes;</span><br><span class="line">  style?: VNodeStyle;</span><br><span class="line">  dataset?: Dataset;</span><br><span class="line">  on?: On;</span><br><span class="line">  hero?: Hero;</span><br><span class="line">  attachData?: AttachData;</span><br><span class="line">  hook?: Hooks;</span><br><span class="line">  key?: Key;</span><br><span class="line">  ns?: string; <span class="comment">// for SVGs</span></span><br><span class="line">  fn?: <span class="function"><span class="params">()</span> =&gt;</span> VNode; <span class="comment">// for thunks</span></span><br><span class="line">  args?: <span class="built_in">Array</span>&lt;any&gt;; <span class="comment">// for thunks</span></span><br><span class="line">  [key: string]: any; <span class="comment">// for any other 3rd party module</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>vnode的结构可以从定义的接口看出</p><h3 id="分析">分析</h3><p><a href="https://github.com/snabbdom/snabbdom/blob/master/src/snabbdom.ts#L195" target="_blank" rel="noopener">这段代码</a>也就是我们常说的diff，也就是updateChildren的这个函数，接受了两个children数组来进行对比</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateChildren</span>(<span class="params">parentElm: Node,</span></span></span><br><span class="line"><span class="function"><span class="params">                        oldCh: Array&lt;VNode&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">                        newCh: Array&lt;VNode&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">                        insertedVnodeQueue: VNodeQueue</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> oldStartIdx = <span class="number">0</span>, newStartIdx = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> oldEndIdx = oldCh.length - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> oldStartVnode = oldCh[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">let</span> oldEndVnode = oldCh[oldEndIdx];</span><br><span class="line">  <span class="keyword">let</span> newEndIdx = newCh.length - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> newStartVnode = newCh[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">let</span> newEndVnode = newCh[newEndIdx];</span><br><span class="line">  <span class="keyword">let</span> oldKeyToIdx: any;</span><br><span class="line">  <span class="keyword">let</span> idxInOld: number;</span><br><span class="line">  <span class="keyword">let</span> elmToMove: VNode;</span><br><span class="line">  <span class="keyword">let</span> before: any;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//通过以上的几个变量来做到逐个的比较</span></span><br><span class="line">  <span class="comment">//主要在于oldStart和oldEnd的几个变量</span></span><br><span class="line">  <span class="comment">//通过封装好的sameVnode()的函数来对比，具体的可以自行查看</span></span><br><span class="line">  <span class="comment">//idx控制着每一次循环对比的元素，具体的变化看每一个判断规则所做的变化</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) &#123;</span><br><span class="line">    <span class="keyword">if</span> (oldStartVnode == <span class="literal">null</span>) &#123; <span class="comment">//没有oldStartVnode的时候我们把第一个oldCh的第一个Vnode保存起来</span></span><br><span class="line">      oldStartVnode = oldCh[++oldStartIdx]; <span class="comment">// Vnode might have been moved left</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (oldEndVnode == <span class="literal">null</span>) &#123; </span><br><span class="line">      oldEndVnode = oldCh[--oldEndIdx];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (newStartVnode == <span class="literal">null</span>) &#123;</span><br><span class="line">      newStartVnode = newCh[++newStartIdx];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (newEndVnode == <span class="literal">null</span>) &#123; <span class="comment">//到这位置基本都和上面类似</span></span><br><span class="line">      newEndVnode = newCh[--newEndIdx];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sameVnode(oldStartVnode, newStartVnode)) &#123; <span class="comment">//以上的判断都是设置好变量，这一个判断开始就是真正开始对比的逻辑，直接判断新旧vnode的头元素是否相等</span></span><br><span class="line">      patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue);</span><br><span class="line">      oldStartVnode = oldCh[++oldStartIdx];</span><br><span class="line">      newStartVnode = newCh[++newStartIdx];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sameVnode(oldEndVnode, newEndVnode)) &#123; <span class="comment">//同上，对比尾vnode</span></span><br><span class="line">      patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue);</span><br><span class="line">      oldEndVnode = oldCh[--oldEndIdx];</span><br><span class="line">      newEndVnode = newCh[--newEndIdx];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sameVnode(oldStartVnode, newEndVnode)) &#123; <span class="comment">//对比old头vnode和new尾vnode，相等说明元素移到了末尾</span></span><br><span class="line">      patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue);</span><br><span class="line">      api.insertBefore(parentElm, oldStartVnode.elm <span class="keyword">as</span> Node, api.nextSibling(oldEndVnode.elm <span class="keyword">as</span> Node));</span><br><span class="line">      oldStartVnode = oldCh[++oldStartIdx];</span><br><span class="line">      newEndVnode = newCh[--newEndIdx];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sameVnode(oldEndVnode, newStartVnode)) &#123; <span class="comment">//基本同上，对比old尾vnode和new头vnode相同的话说明元素被移到了头部</span></span><br><span class="line">      patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue);</span><br><span class="line">      api.insertBefore(parentElm, oldEndVnode.elm <span class="keyword">as</span> Node, oldStartVnode.elm <span class="keyword">as</span> Node);</span><br><span class="line">      oldEndVnode = oldCh[--oldEndIdx];</span><br><span class="line">      newStartVnode = newCh[++newStartIdx];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//以上  在所有对比条件都不成立之后，说明基本上的对比逻辑基本走完，剩下的基本是不等的vnode</span></span><br><span class="line">      <span class="comment">// 通过createKeyToOldIdx创建一个json，key和index</span></span><br><span class="line">      <span class="keyword">if</span> (oldKeyToIdx === <span class="literal">undefined</span>) &#123;</span><br><span class="line">        oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);</span><br><span class="line">      &#125;</span><br><span class="line">      idxInOld = oldKeyToIdx[newStartVnode.key <span class="keyword">as</span> string];</span><br><span class="line">      <span class="comment">//扔一个newStartVnode的key到json中，如果没有说明这个newStartVnode是新的节点，直接创建并且插到最前面</span></span><br><span class="line">      <span class="keyword">if</span> (isUndef(idxInOld)) &#123; <span class="comment">// New element</span></span><br><span class="line">        api.insertBefore(parentElm, createElm(newStartVnode, insertedVnodeQueue), oldStartVnode.elm <span class="keyword">as</span> Node);</span><br><span class="line">        newStartVnode = newCh[++newStartIdx];</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//如果在json中找到了对应的节点，说明已经有了变更</span></span><br><span class="line">        elmToMove = oldCh[idxInOld];</span><br><span class="line">        <span class="comment">//这里需要判断一下sel是否相等，不等说明节点类型已经改变创建新节点</span></span><br><span class="line">        <span class="keyword">if</span> (elmToMove.sel !== newStartVnode.sel) &#123;</span><br><span class="line">          api.insertBefore(parentElm, createElm(newStartVnode, insertedVnodeQueue), oldStartVnode.elm <span class="keyword">as</span> Node);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">//如果节点类型相等的话就直接扔到patchVnode 对应修改一遍属性，并且移动到最前面</span></span><br><span class="line">          patchVnode(elmToMove, newStartVnode, insertedVnodeQueue);</span><br><span class="line">          oldCh[idxInOld] = <span class="literal">undefined</span> <span class="keyword">as</span> any;</span><br><span class="line">          api.insertBefore(parentElm, (elmToMove.elm <span class="keyword">as</span> Node), oldStartVnode.elm <span class="keyword">as</span> Node);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//那最后 我们每处理完一个newVnode就将idx+1</span></span><br><span class="line">        newStartVnode = newCh[++newStartIdx];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//如果这里StartIdx依旧小于EndIdx的话， 说明有多余的节点</span></span><br><span class="line">  <span class="keyword">if</span> (oldStartIdx &lt;= oldEndIdx || newStartIdx &lt;= newEndIdx) &#123;        </span><br><span class="line">    <span class="comment">//这一段主要用于删除掉或者添加进去多余或者缺失的节点</span></span><br><span class="line">    <span class="comment">//这一段说明 old节点已经处理完了，我们需要newVnode创建并添加</span></span><br><span class="line">    <span class="keyword">if</span> (oldStartIdx &gt; oldEndIdx) &#123;</span><br><span class="line">      before = newCh[newEndIdx+<span class="number">1</span>] == <span class="literal">null</span> ? <span class="literal">null</span> : newCh[newEndIdx+<span class="number">1</span>].elm;</span><br><span class="line">      addVnodes(parentElm, before, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//这一段说明是new节点处理完成，直接删除多余节点</span></span><br><span class="line">      removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上把代码都做了一个注释，有兴趣的话可以拿张纸笔画画图会比较清晰(自己也是这么做的)。</p><h3 id="一些疑惑和疏漏">一些疑惑和疏漏</h3><ol><li>在查看比较前面的commit发现在最开始有用到<strong>createDocumentFragment</strong>这个api来避免浏览器多次渲染导致的回流和重绘，但发现后面给移除了…不太明白0.0</li><li>hook这个地方实际上有个很小的疑惑，在init的时候可以发现他的hook数组里面一般只有一个回调需要执行，为什么以数组的形式保存，可能是后面还有没写的hook？</li><li>patch的部分也可以细讲(懒了)</li><li>hook的几个函数没讲出来，之后再回头看看吧(咕咕咕)</li></ol><h3 id="水文结束">水文结束</h3><p>优化的细节实际上很多，阅读优秀的开源项目能收获到不少平时写代码的技巧。<br>第一个commit十分简单，可以慢慢翻到补充稍微完整的源码之后再跳着看，这样可能会比较快。<br>最近翻了翻pr，发现作者已经很久没有合并pr或者更新代码了，ci的test好像也有问题…<br>原来是有了新欢<a href="https://github.com/funkia/turbine" target="_blank" rel="noopener">turbine</a>，好像也蛮有意思的，就是相关资料有点少，之后有空的话去看看啦~<br><img src="https://github.com/OctupleSakura/show-img/raw/master/blog/snabbdom/sticker.webp" style="width:300px"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://github.com/snabbdom/snabbdom&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;snabbdom&lt;/a&gt;是非常经典的一个库了。&lt;br&gt;
曾经在知乎上看到有这样一个&lt;a href=&quot;https://www.zhihu.com/question/29380608&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;问题&lt;/a&gt;，发现&lt;strong&gt;virtual-dom&lt;/strong&gt;也是不少人都造过的轮子。&lt;br&gt;
snabbdom的牛逼之处更多在于思想，而不是在于代码有多么的精妙，这一点在react和vue都用virtual-dom的思想去做dom的处理而又对其做了优化这件事情中可见一斑。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="https://octuplesakura.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="https://octuplesakura.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>骨架屏在Vue中的简单实现</title>
    <link href="https://octuplesakura.github.io/2019/01/25/%E9%AA%A8%E6%9E%B6%E5%B1%8F%E5%9C%A8Vue%E4%B8%AD%E7%9A%84%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0/"/>
    <id>https://octuplesakura.github.io/2019/01/25/骨架屏在Vue中的简单实现/</id>
    <published>2019-01-25T02:24:12.000Z</published>
    <updated>2021-03-10T11:12:05.990Z</updated>
    
    <content type="html"><![CDATA[<p>为什么需要骨架屏？骨架屏其实是一项非常不错的优化，可以有效减少pwa项目在渲染dom过程中的白屏时间，相对于loading来说好处在于能让用户感受到项目是在逐步加载，对于用户的感知会显得更加流畅</p><a id="more"></a><p><img src="https://github.com/OctupleSakura/show-img/raw/master/blog/skeleton/skeleton.jpg" alt="facebook"><br>我们在打开facebook的时候也可以看到这玩意儿，尽管他们很早就用上了</p><h3 id="实现">实现</h3><p>首先先来说明一下我们使用的插件<a href="https://github.com/lavas-project/vue-skeleton-webpack-plugin" target="_blank" rel="noopener">vue-skeleton-webpack-plugin</a>，是lavas的webpack相关插件<br>大体分为<strong>3步</strong>:</p><ol><li>创建骨架屏vue文件</li><li>创建skeleton的实例</li><li>在webpack的配置文件中导入skeleton实例</li></ol><p>首先我们需要写一个能让webpack去渲染的一个骨架屏模板，就是skeleton.vue,样式可以自己想，这里就直接拿官方的demo来用了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//skeleton.vue</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"skeleton-wrapper"</span>&gt;</span><br><span class="line">    &lt;section <span class="class"><span class="keyword">class</span></span>=<span class="string">"skeleton-block"</span>&gt;</span><br><span class="line">      &lt;!-- eslint-disable vue/max-len --&gt;</span><br><span class="line">    &lt;<span class="regexp">/section&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>div&gt;</span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">export default &#123;</span></span><br><span class="line"><span class="regexp">  name: 'Skeleton',</span></span><br><span class="line"><span class="regexp">&#125;;</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">.skeleton-block &#123;</span><br><span class="line">  display: flex;</span><br><span class="line">  flex-direction: column;</span><br><span class="line">  padding: <span class="number">16</span>px;</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/style&gt;</span></span><br></pre></td></tr></table></figure><p>创建skeleton实例文件，导入刚刚的文件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span>;</span><br><span class="line"><span class="keyword">import</span> Skeleton <span class="keyword">from</span> <span class="string">'./Skeleton.vue'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    Skeleton,</span><br><span class="line">  &#125;,</span><br><span class="line">  render: <span class="function"><span class="params">h</span> =&gt;</span> h(Skeleton),</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>最后，在vue.config.js里面，用插件去引用实例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这里要先把插件安装好</span></span><br><span class="line"><span class="keyword">const</span> SkeletonWebpackPlugin = <span class="built_in">require</span>(<span class="string">'vue-skeleton-webpack-plugin'</span>)</span><br><span class="line"><span class="keyword">let</span> option = &#123;</span><br><span class="line">  configureWebpack: &#123;</span><br><span class="line">    plugins: [</span><br><span class="line">      <span class="comment">//对应插件</span></span><br><span class="line">      <span class="keyword">new</span> SkeletonWebpackPlugin(&#123;</span><br><span class="line">        webpackConfig: &#123;</span><br><span class="line">          entry: &#123;</span><br><span class="line">            <span class="comment">//入口文件路径</span></span><br><span class="line">            app: path.join(__dirname, <span class="string">'./src/skeleton.entry.js'</span>),</span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">//quiet 选填，在服务端渲染时是否需要输出信息到控制台</span></span><br><span class="line">        quiet: <span class="literal">true</span>,</span><br><span class="line">        <span class="comment">//minimize 选填 SPA 下是否需要压缩注入 HTML 的 JS 代码</span></span><br><span class="line">        minmize: <span class="literal">true</span></span><br><span class="line">      &#125;)</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反正直接照着官方库中的<a href="https://github.com/lavas-project/vue-skeleton-webpack-plugin/tree/master/examples" target="_blank" rel="noopener">examples</a>写就完了，很详细了(逃</p><h3 id="踩过的坑">踩过的坑</h3><p>这里要说明一下，在vue-cli下，实际上<a href="https://github.com/lavas-project/vue-skeleton-webpack-plugin" target="_blank" rel="noopener">vue-skeleton-webpack-plugin</a>这个插件在非线上环境下是有坑的,skeleton的样式会渲染不出来，在官方库的issues当中已经明确被标为bug了，具体的可以看<a href="https://github.com/lavas-project/vue-skeleton-webpack-plugin/issues/52" target="_blank" rel="noopener">这里</a></p><h3 id="参考链接">参考链接</h3><p><a href="https://juejin.im/post/5b79a2786fb9a01a18267362" target="_blank" rel="noopener">Vue项目骨架屏注入实践</a> — 介绍了大概的概念和几种注入方式<br><a href="https://segmentfault.com/a/1190000014832185" target="_blank" rel="noopener">Vue项目骨架屏注入实践</a> — 腾讯老哥在思否的一篇文章，将服务端注入放到了前端来处理，使用了<strong>vue-server-renderer</strong>插件<br><a href="https://lavas.baidu.com/guide/v2/webpack/vue-skeleton-webpack-plugin" target="_blank" rel="noopener">lavas的webpack相关</a> — lavas是一套vue的pwa解决方案，但是我们只需要使用到相关的一个插件来完成我们想要的</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;为什么需要骨架屏？骨架屏其实是一项非常不错的优化，可以有效减少pwa项目在渲染dom过程中的白屏时间，相对于loading来说好处在于能让用户感受到项目是在逐步加载，对于用户的感知会显得更加流畅&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="https://octuplesakura.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="https://octuplesakura.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="vue" scheme="https://octuplesakura.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>QQ音乐生成guid</title>
    <link href="https://octuplesakura.github.io/2018/05/14/QQ%E9%9F%B3%E4%B9%90%E7%94%9F%E6%88%90guid/"/>
    <id>https://octuplesakura.github.io/2018/05/14/QQ音乐生成guid/</id>
    <published>2018-05-14T09:40:08.000Z</published>
    <updated>2021-03-10T04:43:33.761Z</updated>
    
    <content type="html"><![CDATA[<p>因为之前在用的一个接口突然就403了,因此不得不解析一下QQ音乐原先是怎么获取到音乐资源,QQ音乐的搜索等等应该都挺好拿到的,因为那边没有做太多处理所以就不写了</p><a id="more"></a><h2 id="生成guid">生成guid</h2><p>首先先放一下翻了好多文章才找到的一个方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">getGuid()&#123;</span><br><span class="line">   <span class="keyword">var</span> t = (<span class="keyword">new</span> <span class="built_in">Date</span>).getUTCMilliseconds();</span><br><span class="line">   <span class="keyword">if</span>(<span class="built_in">document</span>.cookie.indexOf(<span class="string">"pgv_pvid"</span>)!=<span class="number">-1</span>)&#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">this</span>.getCookie(<span class="string">"pgv_pvid"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">let</span>  _guid = <span class="built_in">Math</span>.round(<span class="number">2147483647</span> * <span class="built_in">Math</span>.random()) * t % <span class="number">1e10</span>;</span><br><span class="line">   <span class="built_in">document</span>.cookie =<span class="string">"pgv_pvid="</span> + _guid + <span class="string">"; Expires=Sun, 18 Jan 2038 00:00:00 GMT;PATH=/;"</span>;</span><br><span class="line">   <span class="keyword">return</span> _guid</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个是在原文的方法上根据自己的需要进行的一个处理,生成guid之后需要将他放入cookie中并且将这个guid用于请求vkey上<br>这里还做了一个判断,如果没有cookie的话就进行再生成.否则就一直用cookie里面的guid</p><h2 id="获取vkey">获取vkey</h2><p>这里首先放一个链接,用来请求<a href="https://c.y.qq.com/base/fcgi-bin/fcg_music_express_mobile3.fcg?g_tk=1278911659&amp;hostUin=0&amp;format=jsonp&amp;callback=callback&amp;inCharset=utf8&amp;outCharset=utf-8&amp;notice=0&amp;platform=yqq&amp;needNewCode=0&amp;cid=205361747&amp;uin=0&amp;songmid='+songmid+'&amp;filename=C400'+songmid+'.m4a&amp;guid='+guid" target="_blank" rel="noopener">资源</a></p><p>这里的话需要设置的变量有两个,一个是生成的guid,另外一个是songmid,这里是获取到音乐数据的list时候里面会有这个id.同样放进去就好了,之后会返回一个数据,这里也放一下大概的格式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">config</span>:&#123;&#125;,<span class="attr">data</span>:<span class="string">"&#123;&#125;"</span>,<span class="attr">header</span>:&#123;&#125;,<span class="attr">request</span>:&#123;&#125;,<span class="attr">status</span>:<span class="number">200</span>,<span class="attr">statusText</span>:<span class="string">"OK"</span>&#125;</span><br></pre></td></tr></table></figure><p>其中data里面就包含了根据guid请求到的vkey,这样就拿到了我们要的key了</p><h2 id="根据vkey和guid来请求音乐资源">根据vkey和guid来请求音乐资源</h2><p>拿到了vkey和guid,这里就可以直接给audio设置src了,这里放下<a href="http://dl.stream.qqmusic.qq.com/C400002WLzlO1fjnXZ.m4a?guid=6238123201&amp;vkey=45906EDC7FB59B1A8E4420E2403106133F9669AC2F6F71AD43ECA6C85043EA652F14CA06C4F8E8B48BA17D6C447F19FAD8D5B1C36297457E&amp;uin=0&amp;fromtag=38" target="_blank" rel="noopener">路径</a><br>这个地方要设置的只有vkey和guid 就是上面两个步骤拿到的<br>要注意这里的vkey一定是要通过guid生成请求出来的才可以拿到,如果是另一个guid请求到的vkey,那么可能拿不到音乐资源(大概吧hhhh我也没有试过</p><h2 id="参考资料">参考资料</h2><p><a href="http://www.bubuko.com/infodetail-2309843.html" target="_blank" rel="noopener">guid方法的原文</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;因为之前在用的一个接口突然就403了,因此不得不解析一下QQ音乐原先是怎么获取到音乐资源,QQ音乐的搜索等等应该都挺好拿到的,因为那边没有做太多处理所以就不写了&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="https://octuplesakura.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="https://octuplesakura.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="QQ音乐" scheme="https://octuplesakura.github.io/tags/QQ%E9%9F%B3%E4%B9%90/"/>
    
  </entry>
  
</feed>
